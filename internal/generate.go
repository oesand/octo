package internal

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/oesand/octo/internal/decl"
	"io"
	"os"
	"text/template"
)

//go:embed template/*.tmpl
var content embed.FS

const generatedHeaderText = "// Code generated by Octo (https://github.com/oesand/octo). DO NOT EDIT!\n" +
	"//go:build !octogen\n// +build !octogen"

func GenerateFile(filePath string, dcl *decl.PackageDecl) error {
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	return Generate(file, dcl)
}

func Generate(w io.Writer, dcl *decl.PackageDecl) error {
	var headBuf bytes.Buffer
	_, err := headBuf.WriteString(generatedHeaderText + "\n\npackage " + dcl.Name + "\n\n")
	if err != nil {
		return err
	}

	headBuf.WriteString("import (\n")
	headBuf.WriteString("\t\"github.com/oesand/octo\"\n")
	var importAliases map[string]string
	if len(dcl.Imports) > 0 {
		importAliases = make(map[string]string, len(dcl.Imports))
		for i, imp := range dcl.Imports {
			alias := fmt.Sprintf("als%d", i+1)
			importAliases[imp] = alias
			headBuf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, imp))
		}
	}
	headBuf.WriteString(")\n")

	genLocale := func(loc *decl.LocaleInfo, val bool) string {
		res := loc.Name
		if loc.Package != dcl.PkgPath {
			res = importAliases[loc.Package] + "." + res
		}
		if loc.Ptr {
			if val {
				res = "&" + res
			} else {
				res = "*" + res
			}
		}
		return res
	}

	funcMap := template.FuncMap{
		"alias": func(impName string) string {
			if importAliases == nil {
				panic("no imports")
			}

			alias, has := importAliases[impName]
			if !has {
				panic(fmt.Sprintf("unknown package import: %s", impName))
			}
			return alias
		},
		"vlocs": func(loc *decl.LocaleInfo) string {
			return genLocale(loc, true)
		},
		"locs": func(loc *decl.LocaleInfo) string {
			return genLocale(loc, false)
		},
	}

	_, err = headBuf.WriteTo(w)
	if err != nil {
		return err
	}

	err = executeTemplate(w, "octogen.tmpl", funcMap, map[string]any{
		"Funcs": dcl.Funcs,
	})

	return err
}

func executeTemplate(w io.Writer, templateName string, funcMap template.FuncMap, data map[string]any) error {
	tmpl, err := template.New("").Funcs(funcMap).ParseFS(content, fmt.Sprintf("template/%s", templateName))
	if err != nil {
		return err
	}
	err = tmpl.ExecuteTemplate(w, templateName, data)
	if err != nil {
		return err
	}
	return nil
}
